<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Web开发学习</title>
      <link href="2021/01/27/web-kai-fa-xue-xi-23/"/>
      <url>2021/01/27/web-kai-fa-xue-xi-23/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><h2 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h2><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>!ODCTYPE</span> <span class="token attr-name">html</span><span class="token punctuation">></span></span>   //声明该文档是由html5编写的<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>            //html标签，也是根标签    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>第一个程序<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>Hello world<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>  //h1-h6表示标题的尺寸，p是定义一个段落里面是一段文本    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a><a href="">标签</a></h3><p>html是使用标签来描述网页，”&lt;&gt;”中的内容称作标签，通常标签都是一对一对的，第一个出现的成为开始标签，第二个的称之为结束标签，它们的名称和关键词是一样的，只不过结束标签比开始标签在前面加了一个‘/’ ，在这之间的所有代码称之为这个标签的元素，标签中的关键字称之为元素的名称，之间的文本就是元素的内容</p><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p><a href="https://man.ilovefishc.com/pageHTML5/!DOCTYPE.html">!ODCTYPE html</a>  、<a href="https://man.ilovefishc.com/pageHTML5/!--.html">!–…–</a>、<a href="https://man.ilovefishc.com/pageHTML5/base.html">base</a>、<a href="https://man.ilovefishc.com/pageHTML5/html.html">html</a>、<a href="https://man.ilovefishc.com/pageHTML5/br.html">br</a>、<a href="https://man.ilovefishc.com/pageHTML5/dir.html">dir</a>、<a href="https://man.ilovefishc.com/pageHTML5/hr.html">hr</a>、<a href="https://man.ilovefishc.com/pageHTML5/meta.html">meta</a>、<a href="https://man.ilovefishc.com/pageHTML5/head.html">head</a>、<a href="https://man.ilovefishc.com/pageHTML5/body.html">body</a>、<a href="https://man.ilovefishc.com/pageHTML5/title.html">title</a>、<a href="https://man.ilovefishc.com/pageHTML5/h.html">h1-h6</a>、<a href="https://man.ilovefishc.com/pageHTML5/p.html">p</a>、<a href="https://man.ilovefishc.com/pageHTML5/style.html">style</a></p><h4 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h4><p><a href="https://man.ilovefishc.com/pageHTML5/area.html">area</a>、<a href="https://man.ilovefishc.com/pageHTML5/img.html">img</a>、<a href="https://man.ilovefishc.com/pageHTML5/map.html">map</a>、<a href="https://man.ilovefishc.com/pageHTML5/figcaption.html">figcaption</a>、<a href="https://man.ilovefishc.com/pageHTML5/figure.html">figure</a>、<a href="https://man.ilovefishc.com/pageHTML5/picture.html">picture</a></p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://man.ilovefishc.com/pageHTML5/a.html">a</a>、<a href="https://man.ilovefishc.com/pageHTML5/link.html">link</a></p><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p><a href="https://man.ilovefishc.com/pageHTML5/dd.html">dd</a>、<a href="https://man.ilovefishc.com/pageHTML5/dl.html">dl</a>、<a href="https://man.ilovefishc.com/pageHTML5/dt.html">dt</a>、<a href="https://man.ilovefishc.com/pageHTML5/li.html">li</a>、<a href="https://man.ilovefishc.com/pageHTML5/ol.html">ol</a>、<a href="https://man.ilovefishc.com/pageHTML5/ul.html">ul</a></p><h4 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h4><p><a href="https://man.ilovefishc.com/pageHTML5/source.html">source</a>、<a href="https://man.ilovefishc.com/pageHTML5/audio.html">audio</a>、<a href="https://man.ilovefishc.com/pageHTML5/track.html">track</a>、<a href="https://man.ilovefishc.com/pageHTML5/video.html">video</a></p><h4 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h4><p><a href="https://man.ilovefishc.com/pageHTML5/svg.html">svg</a>、<a href="https://man.ilovefishc.com/pageHTML5/canvas.html">canvas</a></p><h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><p><a href="https://man.ilovefishc.com/pageHTML5/time.html">time</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识#文章标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="2021/01/08/shu-ju-jie-gou-15/"/>
      <url>2021/01/08/shu-ju-jie-gou-15/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="图"><a href="#图" class="headerlink" title="图"></a><strong>图</strong></h2><h3 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>时间复杂度：O(n*n)</p><p>空间复杂度：O(n*n)</p><pre class=" language-c/c++"><code class="language-c/c++">typedef struct AGraph&#123;    int vertexe;         //节点的个数     int edge;            //边的个数     int G[MAX_N][MAX_N]; //邻接矩阵 &#125;AGraph;void CreateAGraph(AGraph *G)&#123;    int a,b;    cout<<G->vertexe<<G->edge;//输入节点和边的个数     for(int i=0;i<G->edge;i++)//存储，若为有向图则只存G[a][b],若带权责G[a][b]等于带权值     &#123;        cout<<a<<b;        G->G[a][b]=1;        G->G[b][a]=1;    &#125;&#125;</code></pre><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><h5 id="1-链式"><a href="#1-链式" class="headerlink" title="1.链式"></a>1.链式</h5><p>时间复杂度：O(n+e)</p><pre class=" language-c/c++"><code class="language-c/c++">typedef struct ArcNode       //定义尾节点&#123;    int adjvex;              //节点值    int weight;              //权重    struct ArcNode *next;    //指向下一个节点&#125;ArcNode;typedef struct VerNode       //定义头结点&#123;    int adjvex;              //    ArcNode *FirstArc;       //指向第一个尾节点&#125;VerNode;typedef struct AGraph         //定义图&#123;    int vertexe;                 int edge;                    VerNode AdjList[MAX_N];  //邻接表&#125;AGraph;void CreateAGraph(AGraph *G) //创建图 &#123;   cout<<G->vertexe<<G->edge;   //输入节点与边的个数    for(int i=1;i<=G->vertexe;i++)  //初始化    &#123;        G->AdjList[i]=NULL;    &#125;    ArcNode *p1=(ArcNode*)malloc(sizeof(ArcNode));   ArcNode *p2=(ArcNode*)malloc(sizeof(ArcNode));   for(int i=1;i<=G->edge;i++)        //存储边,有向图注意方向   &#123;           cout<<p1->adjvex<<p1->weight<<p2->adjvex<<p2->weight;           p1->next=G->AdjList[p2->adjvex].FirstArc;           p2->next=G->AdjList[p1->adjvex].FirstArc;           G->AdjList[p2->adjvex].FirstArc=p1->next;           G->AdjList[p1->adjvex].FirstArc=p2->next;   &#125;  &#125;</code></pre><h5 id="2-数组-https-www-cnblogs-com-ECJTUACM-873284962-p-6905416-html"><a href="#2-数组-https-www-cnblogs-com-ECJTUACM-873284962-p-6905416-html" class="headerlink" title="2.数组(https://www.cnblogs.com/ECJTUACM-873284962/p/6905416.html)"></a>2.数组(<a href="https://www.cnblogs.com/ECJTUACM-873284962/p/6905416.html">https://www.cnblogs.com/ECJTUACM-873284962/p/6905416.html</a>)</h5><p>时间复杂度：O(n+e)</p><pre class=" language-c/c++"><code class="language-c/c++">int n,m,i;//u、v和w的数组大小要根据实际情况来设置，要比m的最大值要大1int u[6],v[6],w[6];//first和next的数组大小要根据实际情况来设置，要比n的最大值要大1int first[5],next[5];scanf("%d %d",&n,&m);//初始化first数组下标1~n的值为-1，表示1~n顶点暂时都没有边for(i=1;i<=n;i++)    first[i]=-1;for(i=1;i<=m;i++)&#123;    scanf("%d %d %d",&u[i],&v[i],&w[i]);//读入每一条边    //下面两句是关键啦    next[i]=first[u[i]];    first[u[i]]=i;&#125;//遍历其中一个点k=first[1];// 1号顶点其中的一条边的编号（其实也是最后读入的边）while(k!=-1) //其余的边都可以在next数组中依次找到&#123;    printf("%d %d %d\n",u[k],v[k],w[k]);    k=next[k];&#125;//遍历全部for(i=1;i<=n;i++)&#123;    k=first[i];    while(k!=-1)    &#123;        printf("%d %d %d\n",u[k],v[k],w[k]);        k=next[k];    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识#文章标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习</title>
      <link href="2020/11/23/c-yu-yan-xue-xi/"/>
      <url>2020/11/23/c-yu-yan-xue-xi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java学习</title>
      <link href="2020/11/23/java-xue-xi/"/>
      <url>2020/11/23/java-xue-xi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++基础学习笔记</title>
      <link href="2020/11/23/c-xue-xi-bi-ji-2/"/>
      <url>2020/11/23/c-xue-xi-bi-ji-2/</url>
      
        <content type="html"><![CDATA[<h1 id="一个简单小程序"><a href="#一个简单小程序" class="headerlink" title="一个简单小程序"></a>一个简单小程序</h1><pre class=" language-c++"><code class="language-c++">#include<iostream> //定义ostream 类using namespace std; //命名空间int main()&#123;    int a,b;    cin>>a>>b;    cout>>a+b;    return 0; &#125;</code></pre><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="const"><a href="#const" class="headerlink" title="*const"></a>*const</h3><p>声明一个只读的常量，常量的值不能改变(本质自己搜）；//可配合指针使用</p><h2 id="输入流cin相关函数"><a href="#输入流cin相关函数" class="headerlink" title="输入流cin相关函数"></a>输入流cin相关函数</h2><h3 id="cin-get"><a href="#cin-get" class="headerlink" title="cin.get()"></a>cin.get()</h3><p>int ch=cin.get()/cin.get(ch)//输入一个字符</p><p>cin.get()//吞掉一个字符，多用于吞‘回车’<br>cin.get(str/ch[] , n , ch )//输入字符串或字符数组，n是输入个数，ch是停止标志；</p><h3 id="cin-peek"><a href="#cin-peek" class="headerlink" title="cin.peek()"></a>cin.peek()</h3><p>ch=cin.peek()//读取流中的第一个字符，但字符还在流中，相当于偷窥的</p><h3 id="cin-ignore"><a href="#cin-ignore" class="headerlink" title="cin.ignore()"></a>cin.ignore()</h3><p>cin.ignore(int max,char ch); //忽略字符，max是忽略的个数，ch是停止标志</p><h3 id="cin-getline"><a href="#cin-getline" class="headerlink" title="cin.getline()"></a>cin.getline()</h3><p>cin.getline(ch[], max , ch) //输入一行, ch[]是输入进的数组， max是输入的个数， ch为输入停止的标志</p><h3 id="cin-read"><a href="#cin-read" class="headerlink" title="cin.read()"></a>cin.read()</h3><p>cin.read(n=ch[]/str , n)// 从输入流读取n个字符到ch[]/str 中</p><h3 id="cin-gcount"><a href="#cin-gcount" class="headerlink" title="cin.gcount()"></a>cin.gcount()</h3><p>输出读取字符的个数；//getline对gcount有影响</p><h3 id="cin-putback"><a href="#cin-putback" class="headerlink" title="cin.putback()"></a>cin.putback()</h3><p>cin.putback(ch);//将ch退回输入流中</p><h3 id="cin-width"><a href="#cin-width" class="headerlink" title="cin.width()"></a>cin.width()</h3><p>cin.width(n) // 从输入流中读取n个字符的字符串，由于字符串最后一个字符为0，所以最多读取n-1个字符，并且遇到空格会停止读取</p><h2 id="输出流cout相关函数"><a href="#输出流cout相关函数" class="headerlink" title="输出流cout相关函数"></a>输出流cout相关函数</h2><h3 id="cout-put"><a href="#cout-put" class="headerlink" title="cout.put()"></a>cout.put()</h3><p>cout.put(ch) //输出一个字符</p><h3 id="cout-write"><a href="#cout-write" class="headerlink" title="cout.write()"></a>cout.write()</h3><p>cout.write(str ,  n) //输出字符串str ，n表示输出的个数</p><h3 id="cout-precision"><a href="#cout-precision" class="headerlink" title="cout.precision()"></a>cout.precision()</h3><p>cout.precision(n);//格式控制函数，控制输出小数的位数</p><h3 id="cout-width"><a href="#cout-width" class="headerlink" title="cout.width()"></a>cout.width()</h3><p>cout.width(n)// 格式控制函数，最多输出n个字符，如果不足，在前面补空格</p><h3 id="cout-setf"><a href="#cout-setf" class="headerlink" title="* cout.setf()"></a>* cout.setf()</h3><p>格式控制</p><h2 id="函数的重载"><a href="#函数的重载" class="headerlink" title="函数的重载"></a>函数的重载</h2><p>对相同名称的函数输入不同的数量或类型的参数，分别使用不同的方法</p><p>函数要分开实现；</p><h2 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>定义   void a[100];</p><p>赋值    a[n]=0;</p><p>注意 创建时最好先初始化，输入时一般用循环</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>定义  string str</p><p>赋值  str=’12345’;</p><p>注意  输入时一般用cin.getline()函数</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>定义   void  *p;</p><p>赋值   p= &a;</p><p>注意   一般用于和其他数据类型连用，便于运算</p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>定义  struct  week</p><p>{</p><p>string   today;</p><p>string  tianqi;</p><p>};w</p><p>week  day;</p><p>赋值</p><p>day.today=’mo’;</p><p>day.tianqi=’qingtian’;</p><p>注意   和指针联用效果更佳</p><h3 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h3><p>定义</p><p>union  week</p><p>{</p><p>string   today;</p><p>string  tianqi;</p><p>};</p><p>week day;</p><p>赋值</p><p>day.today=’mo’;</p><p>注意 联合只能给其中一个赋值</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>定义 enum  week{mo,tu,tr,rh,fr };</p><p>week today;</p><p>赋值   today = mo;</p><p>注意 赋值时不要加单引号，枚举的值不是字符串，而是由先后顺序相对应0-n的整数，可以对变量的可取值加以限制，可以作为switch语句中case的编号。</p><h2 id="文件"><a href="#文件" class="headerlink" title="* 文件()"></a>* 文件()</h2><h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><pre class=" language-c++"><code class="language-c++">class  car&#123;    public :        string  name;        string  yq;    //不予许对常量赋值，但可以创建静态常量        double  yl;        string  cla;        void run(double yl);        void color(string cla);&#125;;void car::run(double yl)&#123;&#125;void car::color(string cla)&#123;&#125;int main()&#123;    car mycar,car2;    mycar.yl=200;    maycar.color(rad);    car2=mycar;   //把mycar所有值赋给car2&#125;</code></pre><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>class car{</p><p>public :</p><p>​        car();</p><p>}</p><p>每一个类都会有一个构造器，如果没有定义编译器会自动帮我们定义一个空的构造器</p><p>构造器一般用来初始化和分配内存，所以越简单越好</p><p>和普通方法的区别：1.名字和坐在的类的名字一样  2.系统在创建某个类的实例时会第一时间调动这个类的构造器  3、构造器不会有任何</p><p>的返回值</p><h2 id="析构器"><a href="#析构器" class="headerlink" title="析构器"></a>析构器</h2><p>class  car{</p><p>public:</p><p>​       ~car();</p><p>}</p><p>析构器一般用来事后清理内存，所以受是非常重要的，不小心的话可能会引起内存泄漏</p><p>析构器和构造器名字一样，但前面加了一个~</p><p>析构器不返回任何值，而且不带参数</p><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>class  Human{</p><p>char  name;</p><p>Human(char name);</p><p>}</p><p>Human::Human (char name)</p><p>{</p><p>this-&gt;name  =name;</p><p>}</p><p>就相当于是类的指针</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>如果要写两个类（A和B），B类中有A类的方法，我们就可以让B类去继承A类从而获得A类中的方法</p><p>A类就叫做父类(基类)，B类就叫做子类</p><p>class B: public A{};</p><p>构造器的继承：B::B(string name):A(name){};   //当调用B的构造器，A的构造器也将被调用，相当于把参数传给A</p><p>析构器的继承编译器会自动完成</p><h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>访问控制是c++对类中的属性和方法的保护，可以防止被别人调用</p><p>public：任何代码都可以访问</p><p>protected：只有本身和子类可以访问</p><p>private：仅仅本身可以访问</p><p>限制范围，知道下一个访问级别或类的末尾</p><h2 id="覆盖与重载"><a href="#覆盖与重载" class="headerlink" title="覆盖与重载"></a>覆盖与重载</h2><p>覆盖</p><p>在子类再次声明，并实现</p><p><a href="">重载</a>同上，而且继承之后不能重载</p><h2 id="友元关系"><a href="#友元关系" class="headerlink" title="友元关系"></a>友元关系</h2><p>是类之间的一种关系，这种关系可以是友元类随便访问本类的属性和方法（即使是private也可以访问）</p><p>声明：只需在类中添加 friend class  ***</p><h2 id="静态属性和静态方法"><a href="#静态属性和静态方法" class="headerlink" title="静态属性和静态方法"></a>静态属性和静态方法</h2><p>静态属性  当用static关键词声明一个变量，则这个变量到程序结束时才会被释放，就可以当做一个全局变量使用</p><p>class A{</p><p>private :</p><p> static  int a;</p><p>}</p><p>int A::a=0   //静态属性必须要初始化</p><h2 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h2><p>virtual  void  play ();</p><p>虚方法是可以继承的，一旦某个基类有个方法声明为虚方法，则其子类中这个方法</p><p>如果不确定是否使用虚方法，那就用虚方法，在基类中把所有方法都声明为虚方法只有好处没有坏处，，在实现一个多层次的继承关系时，最顶级的基类应该只有虚方法，析构器也是虚方法</p><h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>virtual  void play()=0;</p><p>就是虚方法不任何实现；</p><h2 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h2><p>用同一个名字定义不同的函数，或者是调用同一个名称的函数，执行不同的操作方法 </p><p>编译时的多态性：通过重载实现，运行速度快    运行时的多态性：通过虚函数实现，高度灵活和抽象</p><h2 id="运算符的重载"><a href="#运算符的重载" class="headerlink" title="运算符的重载"></a>运算符的重载</h2><p>函数类型   operator  运算符名称（形参）{</p><p>对运算符处理;</p><p>}</p><p>有五种运算符不能重载：’.’  ,  ‘*’  ,  ‘::’   ,  ‘sizeof’  ,  ‘?:’</p><p>重载不能改变运算对象的个数，不能改变运算的优先级，不能改变运算符的结合性，重载运算符的函数不能有默认的参数，重载运算符必须和用户自定义的自定义类型的对象一起使用，其参数至少应该有一个是类对象或类对象的引用</p><p>不要随便使用，</p><p>*重载&lt;&lt;操作符</p><h2 id="多继承"><a href="#多继承" class="headerlink" title="*多继承"></a>*多继承</h2><p>当此类有不止一个基类的属性时，同时继承所有基类</p><p>class A : public B,public C{</p><p>} </p><h2 id="虚继承"><a href="#虚继承" class="headerlink" title="*虚继承"></a>*虚继承</h2><p>为了解决多继承属性重复问题</p><p>class A : virtual public B{</p><p>}</p><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><h2 id="处理编译时错误的建议"><a href="#处理编译时错误的建议" class="headerlink" title="处理编译时错误的建议"></a>处理编译时错误的建议</h2><p>1、养成一种自己的敲代码风格</p><p>2、认真对待编译器给出的错误或警告信息</p><p>3、三思而后行（敲代码之前，先规划好流程图，发现错误之后，先阅读一遍在改错）</p><p>4、注意检查最基本的语法</p><p>5、把可能有错误的代码改成注释</p><p>6、换一个环境或编译试试</p><p>7、检查自己是否把所有必要的头文件全部include进来</p><p>8、留意变量的作用域或命名空间</p><p>9、休息一下，为了代码不值得</p><p>10、多使用调试工具 </p><h2 id="处理运行时的错误的建议"><a href="#处理运行时的错误的建议" class="headerlink" title="处理运行时的错误的建议"></a>处理运行时的错误的建议</h2><p>1、多注释，用好注释</p><p>2、注意操作符的优先级</p><p>3、千万不要忘记对用户输入和文件输入进行合法性检查</p><p>4、不要做任何假设</p><p>5、把程序划分成小的单元块来检查</p><h2 id="测试函数"><a href="#测试函数" class="headerlink" title="*测试函数"></a>*测试函数</h2><p>多使用assert函数判断运行时的值与假设的是否一样  //需要调用<classert>头文件</p><p>多使用cout输出值来判断</p><p>捕获异常</p><p>try{</p><p>}catch()</p><p>{</p><p>}</p><p>try  functionName(arguments)throw(type);   /  /捕获函数异常</p><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h2><p>动态内存是由一些没有名字，只有地址的内存块构成，那些内存块是在程序运行期间动态分配的</p><p>他们来自一个由标准C++库替你管理的大池子</p><p>从内存池申请一些内存需要用new语句，他将根据你提供的数据类型分配一块大小适中的内存。</p><p>如果有足够的内存能满足你的申请，new语句将返回新的起始地址</p><p>在用完内存块之后应该用delete语句把它还给内存池，为了保险也把与之关联的指针指向NULL</p><h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>int *a = new int[10];</p><p>delete [] a;</p><h2 id="从函数中返回指针"><a href="#从函数中返回指针" class="headerlink" title="从函数中返回指针"></a>从函数中返回指针</h2><p>在函数中调用new语句为某个对象分配内存，在把那块内存返回给程序</p><p>int *sum(int *a){</p><p>int *s = new int;</p><p>s=a;</p><p>return s;</p><p>}</p><h1 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h1><h2 id="副本构造器（p37）"><a href="#副本构造器（p37）" class="headerlink" title="*副本构造器（p37）"></a>*副本构造器（<a href="https://www.bilibili.com/video/BV1Ps411w73m?p=37">p37</a>）</h2><h2 id="强制类型转换（p38）"><a href="#强制类型转换（p38）" class="headerlink" title="*强制类型转换（p38）"></a>*强制类型转换（<a href="https://www.bilibili.com/video/BV1Ps411w73m?p=38">p38</a>）</h2><h2 id="避免内存泄漏（p39）"><a href="#避免内存泄漏（p39）" class="headerlink" title="避免内存泄漏（p39）"></a>避免内存泄漏（<a href="https://www.bilibili.com/video/BV1Ps411w73m?p=39">p39</a>）</h2><h2 id="头文件（p40，p41）"><a href="#头文件（p40，p41）" class="headerlink" title="头文件（p40，p41）"></a>头文件（<a href="https://www.bilibili.com/video/BV1Ps411w73m?p=40">p40</a>，<a href="https://www.bilibili.com/video/BV1Ps411w73m?p=41">p41</a>）</h2><h2 id="命名空间（p42）"><a href="#命名空间（p42）" class="headerlink" title="命名空间（p42）"></a>命名空间（<a href="https://www.bilibili.com/video/BV1Ps411w73m?p=42">p42</a>）</h2><h2 id="链接和作用域（p43，p44）"><a href="#链接和作用域（p43，p44）" class="headerlink" title="链接和作用域（p43，p44）"></a>链接和作用域（<a href="https://www.bilibili.com/video/BV1Ps411w73m?p=43">p43</a>，<a href="https://www.bilibili.com/video/BV1Ps411w73m?p=44">p44</a>）</h2><h2 id="模板（p45，p46，p47）"><a href="#模板（p45，p46，p47）" class="headerlink" title="模板（p45，p46，p47）"></a>模板（<a href="https://www.bilibili.com/video/BV1Ps411w73m?p=45">p45</a>，<a href="https://www.bilibili.com/video/BV1Ps411w73m?p=46">p46</a>，<a href="https://www.bilibili.com/video/BV1Ps411w73m?p=47">p47</a>）</h2><h3 id="函数（p45）"><a href="#函数（p45）" class="headerlink" title="函数（p45）"></a>函数（<a href="https://www.bilibili.com/video/BV1Ps411w73m?p=45">p45</a>）</h3><h3 id="类（p46）"><a href="#类（p46）" class="headerlink" title="类（p46）"></a>类（<a href="https://www.bilibili.com/video/BV1Ps411w73m?p=46">p46</a>）</h3><h3 id="内联模板（p47）"><a href="#内联模板（p47）" class="headerlink" title="内联模板（p47）"></a>内联模板（<a href="https://www.bilibili.com/video/BV1Ps411w73m?p=47">p47</a>）</h3><h2 id="容器与算法（p48，p49）"><a href="#容器与算法（p48，p49）" class="headerlink" title="容器与算法（p48，p49）"></a>容器与算法（<a href="https://www.bilibili.com/video/BV1Ps411w73m?p=48">p48</a>，<a href="https://www.bilibili.com/video/BV1Ps411w73m?p=49">p49</a>）</h2>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知识 · C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我制作bolg用的东西</title>
      <link href="2020/10/25/wo-zhi-zuo-blog-yong-de-gong-ju-5/"/>
      <url>2020/10/25/wo-zhi-zuo-blog-yong-de-gong-ju-5/</url>
      
        <content type="html"><![CDATA[<p>搭建博客</p><p><a href="https://www.bilibili.com/video/BV1Yb411a7ty?t=586">https://www.bilibili.com/video/BV1Yb411a7ty?t=586</a></p><p>下载主题（matery）</p><p><a href="http://blinkfox.com/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/">http://blinkfox.com/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/</a></p><p>修改主题让你的blog更能体现你的个性</p><p><a href="https://yafine-blog.cn/posts/8c84.html">https://yafine-blog.cn/posts/8c84.html</a></p><p><a href="https://yafine-blog.cn/posts/12b4.html">https://yafine-blog.cn/posts/12b4.html</a></p><p>图片CDN加速</p><p><a href="https://www.bilibili.com/video/BV1rt411a7pf?t=165">https://www.bilibili.com/video/BV1rt411a7pf?t=165</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>杂七杂八的函数</title>
      <link href="2020/10/25/za-qi-za-ba-de-han-shu-18/"/>
      <url>2020/10/25/za-qi-za-ba-de-han-shu-18/</url>
      
        <content type="html"><![CDATA[<h6 id="1-ungetc-unget-putback"><a href="#1-ungetc-unget-putback" class="headerlink" title="1.ungetc(), unget(), putback"></a>1.ungetc(), unget(), putback</h6><p>cin.unget()//把最后一个字符退回到流中</p><p>cin.putback(ch);//把指定的一个字符退回到流中</p><p>ungetc(ch,stdin);//把ch 退回到流中</p>]]></content>
      
      
      
        <tags>
            
            <tag> 知识#文章标签 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
